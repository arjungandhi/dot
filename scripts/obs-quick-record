#!/bin/bash
# OBS Quick Record Toggle
# Auto-starts OBS, switches to recording scene, and toggles recording

# Configuration
OBS_HOST="localhost"
OBS_PORT="4455"  # OBS Studio 28+ uses port 4455 by default
RECORDING_SCENE="Quick Demo"  # Name of the scene to use for recording
OBS_STARTUP_WAIT=3  # Seconds to wait for OBS to start
STATUS_FILE="/tmp/obs-recording-status"

# Function to update status for waybar
update_status() {
    local status=$1
    local icon=""
    local tooltip=""

    case $status in
        "idle")
            icon="ó°•§"  # video camera icon
            tooltip="OBS Ready"
            ;;
        "recording")
            icon="ó°‘Š"  # recording dot
            tooltip="Recording in progress"
            ;;
        "error")
            icon="ó°…–"  # error icon
            tooltip="OBS Error"
            ;;
    esac

    mkdir -p "$(dirname "$STATUS_FILE")"
    echo "{\"text\": \"$icon\", \"tooltip\": \"$tooltip\", \"class\": \"$status\"}" > "$STATUS_FILE"
}

# Initialize status as idle on first run
if [ ! -f "$STATUS_FILE" ]; then
    update_status "idle"
fi

# Check if OBS is running, if not start it
if ! pgrep -x obs > /dev/null; then
    obs --minimize-to-tray --scene "$RECORDING_SCENE" &>/dev/null &
    sleep $OBS_STARTUP_WAIT
fi

# Use Python to control OBS via WebSocket v5 and capture output
OUTPUT=$(python3 << 'PYTHON_SCRIPT'
import sys
from obsws_python import ReqClient
import os

host = "localhost"
port = 4455
password = ""

try:
    cl = ReqClient(host=host, port=port, password=password)

    # Try to switch to the recording scene if it exists
    try:
        scenes = cl.get_scene_list()
        scene_names = [scene['sceneName'] for scene in scenes.scenes]

        if "Quick Demo" in scene_names:
            current_scene = cl.get_current_program_scene()
            if current_scene.current_program_scene_name != "Quick Demo":
                cl.set_current_program_scene("Quick Demo")
    except Exception as e:
        pass  # Scene might not exist yet, that's okay

    # Get current recording status before toggle
    status_before = cl.get_record_status()
    was_recording = status_before.output_active

    # Toggle recording
    cl.toggle_record()

    # Wait for OBS to update status
    import time
    time.sleep(1.0)

    # Get new recording status
    status_after = cl.get_record_status()
    is_recording = status_after.output_active

    # If we just stopped recording, print the output path for notification
    if was_recording and not is_recording:
        # Get the output filename (most recent file in recordings dir)
        import glob
        recordings_dir = os.path.expanduser("~/recordings")
        files = glob.glob(os.path.join(recordings_dir, "*.mp4"))
        if files:
            latest_file = max(files, key=os.path.getctime)
            filename = os.path.basename(latest_file)
            print(filename)  # This will be captured by bash
        sys.exit(1)  # Stopped
    else:
        sys.exit(0)  # Started

except Exception as e:
    os.system(f'notify-send -t 2000 "OBS Recording" "Error: {str(e)}"')
    sys.exit(2)
PYTHON_SCRIPT
)

# Check exit code and update status
EXIT_CODE=$?
if [ $EXIT_CODE -eq 0 ]; then
    update_status "recording"
elif [ $EXIT_CODE -eq 1 ]; then
    update_status "idle"
    # Show notification with filename if recording was stopped
    if [ -n "$OUTPUT" ]; then
        notify-send -t 5000 "Recording Saved" "ðŸ“¹ $OUTPUT"
    fi
elif [ $EXIT_CODE -eq 2 ]; then
    update_status "error"
fi
