#!/usr/bin/env python3
"""
Voice-to-text input using Faster Whisper.
Hold-to-record: records while running, transcribes when stopped.
Updates status file for waybar integration.

Usage:
    voice-input start    # Start recording
    voice-input stop     # Stop recording and transcribe
    voice-input init     # Initialize status file
    voice-input          # Run recording (same as start but foreground)
"""

import sys
import os
import tempfile
import subprocess
import signal
import time

# Lazy imports for heavy libraries - only import when needed
# This significantly speeds up start/stop commands

# Configuration
SAMPLE_RATE = 16000
CHANNELS = 1
MODEL_SIZE = "base"  # Options: tiny, base, small, medium, large-v2, large-v3
STATUS_FILE = "/tmp/voice-input-status"
PID_FILE = "/tmp/voice-input.pid"
CACHE_DIR = os.path.expanduser("~/.cache/voice-input")

# Global variables for signal handling
recording_data = []
stream = None
stop_recording = False

def update_status(status, text=""):
    """Update status file for waybar."""
    os.makedirs(os.path.dirname(STATUS_FILE), exist_ok=True)

    status_icons = {
        "idle": "󰍬",      # microphone icon
        "recording": "󰑊", # recording icon
        "transcribing": "󰔟", # loading/processing icon
        "typing": "󰗧",    # keyboard icon
        "error": "󰅖"      # error/x icon
    }

    icon = status_icons.get(status, "")

    with open(STATUS_FILE, 'w') as f:
        if text:
            f.write(f'{{"text": "{icon}", "tooltip": "{text}", "class": "{status}"}}')
        else:
            f.write(f'{{"text": "{icon}", "class": "{status}"}}')

def init():
    """Initialize voice input status file."""
    update_status("idle")
    print("Voice input initialized", file=sys.stderr)

def start():
    """Start recording in background."""
    # Check if already recording
    if os.path.exists(PID_FILE):
        print("Already recording", file=sys.stderr)
        return

    # Kill any zombie processes
    subprocess.run(["pkill", "-9", "voice-input"], stderr=subprocess.DEVNULL)

    # Start in background
    proc = subprocess.Popen([sys.executable, __file__],
                           stdout=subprocess.DEVNULL,
                           stderr=subprocess.DEVNULL)

    # Save PID
    with open(PID_FILE, 'w') as f:
        f.write(str(proc.pid))

    print(f"Recording started (PID: {proc.pid})", file=sys.stderr)

def stop():
    """Stop recording and transcribe."""
    if os.path.exists(PID_FILE):
        with open(PID_FILE, 'r') as f:
            pid = int(f.read().strip())

        try:
            os.kill(pid, signal.SIGTERM)
            print(f"Stopped recording (PID: {pid})", file=sys.stderr)
        except ProcessLookupError:
            print("No recording process found", file=sys.stderr)

        # Clean up PID file
        os.remove(PID_FILE)
    else:
        print("No active recording", file=sys.stderr)

def audio_callback(indata, frames, time_info, status):
    """Callback for continuous audio recording."""
    if status:
        print(f"Audio callback status: {status}", file=sys.stderr)
    recording_data.append(indata.copy())

def signal_handler(signum, frame):
    """Handle termination signals to stop recording gracefully."""
    global stop_recording, stream
    stop_recording = True
    if stream:
        stream.stop()
        stream.close()

def transcribe_audio(audio_path, model_size=MODEL_SIZE):
    """Transcribe audio file using Faster Whisper."""
    from faster_whisper import WhisperModel

    print("Loading Whisper model...", file=sys.stderr)

    os.makedirs(CACHE_DIR, exist_ok=True)

    model = WhisperModel(
        model_size,
        device="cpu",
        compute_type="int8",
        download_root=CACHE_DIR
    )

    print("Transcribing...", file=sys.stderr)
    segments, info = model.transcribe(audio_path, beam_size=5)

    transcription = " ".join([segment.text for segment in segments])
    return transcription.strip()

def type_text(text):
    """Type the text using wtype (Wayland)."""
    if not text:
        print("No text to type!", file=sys.stderr)
        return

    print(f"Typing: {text}", file=sys.stderr)
    subprocess.run(["wtype", text], check=True)

def record():
    """Main recording function."""
    import sounddevice as sd
    import numpy as np
    from scipy.io import wavfile

    global recording_data, stream, stop_recording

    signal.signal(signal.SIGTERM, signal_handler)
    signal.signal(signal.SIGINT, signal_handler)

    try:
        print("Recording... (will stop when process is killed)", file=sys.stderr)
        update_status("recording", "Recording audio...")

        recording_data = []

        stream = sd.InputStream(
            samplerate=SAMPLE_RATE,
            channels=CHANNELS,
            dtype=np.int16,
            callback=audio_callback
        )

        stream.start()

        while not stop_recording:
            time.sleep(0.1)

        stream.stop()
        stream.close()

        if not recording_data:
            print("No audio recorded!", file=sys.stderr)
            update_status("idle")
            return

        audio_data = np.concatenate(recording_data, axis=0)

        # Skip if recording is too short (less than 0.5 seconds)
        if len(audio_data) < SAMPLE_RATE * 0.5:
            print("Recording too short, skipping.", file=sys.stderr)
            update_status("idle")
            return

        with tempfile.NamedTemporaryFile(suffix=".wav", delete=False) as temp_audio:
            temp_path = temp_audio.name

        wavfile.write(temp_path, SAMPLE_RATE, audio_data)

        update_status("transcribing", "Transcribing audio...")
        text = transcribe_audio(temp_path)

        os.unlink(temp_path)

        if text:
            update_status("typing", f"Typing: {text[:50]}...")
            type_text(text)
            print(f"Transcribed and typed: {text}", file=sys.stderr)
        else:
            print("No speech detected!", file=sys.stderr)

        update_status("idle")

    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        import traceback
        traceback.print_exc()
        update_status("error", str(e))
        sys.exit(1)

def main():
    if len(sys.argv) > 1:
        command = sys.argv[1]
        if command == "init":
            init()
        elif command == "start":
            start()
        elif command == "stop":
            stop()
        else:
            print(f"Unknown command: {command}", file=sys.stderr)
            print("Usage: voice-input [init|start|stop]", file=sys.stderr)
            sys.exit(1)
    else:
        # No command given, run recording
        record()

if __name__ == "__main__":
    main()
